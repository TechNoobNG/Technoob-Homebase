#!/usr/bin/env node

const dotenv = require('dotenv');
const cluster = require('cluster');
const os = require('os');
const http = require('http');
const debug = require('debug')('server:server');
const app = require('../app');
const workerApp = require('../worker/beanstalk/worker');
const db = require('../utils/connectors/db_connector');
const { client, redisSubscriber } = require("../utils/connectors/redishelper");
const config = require('../config/config');
const queueWorker = require(`../worker/${config.WORKER_QUEUE_PLATFORM}/worker`);

dotenv.config({ path: './.env' });

const numCPUs = os.cpus().length;
const HOST = process.env.HOST || 'localhost';
const PORT = normalizePort(process.env.PORT || '3000');
const WORKERS = process.env.WEB_CONCURRENCY || 1; // HEROKU CONFIG

let server;

async function startServer() {
  try {
    await initialiseDB();
    if (HOST !== 'heroku') {
      await connectToRedis();
    }

    server = createServerInstance();
    server.listen(server.port);
    
    server.on('error', onError);
    server.on('listening', onListening);

    console.log(`${server.type} running at http://${HOST}:${server.port}/`);
  } catch (error) {
    console.error("Error starting server:", error);
    process.exit(1);
  }
}

function createServerInstance() {
  if (config.NODE_ENV === "production_worker") {
    return createWorkerServer();
  } else {
    return createAppServer();
  }
}

function createWorkerServer() {
  const workerServer = http.createServer(workerApp);
  workerServer.port = 80;
  workerServer.type = "Worker";
  return workerServer;
}

function createAppServer() {
  const appServer = http.createServer(app);
  appServer.port = PORT;
  appServer.type = "Server";
  return appServer;
}

function initialiseDB() {
  return new Promise((resolve, reject) => {
    db.on('error', (err) => {
      console.error('Database connection error:', err);
      reject(err);
    });
    db.once('open', () => {
      console.log("Connected to database");
      resolve();
    });
  });
}

async function connectToRedis() {
  try {
    await client.connect();
    await redisSubscriber.connect();
    console.log("Connected to Redis");
  } catch (error) {
    console.error("Error connecting to Redis:", error);
    throw error;
  }
}

function normalizePort(val) {
  const port = parseInt(val, 10);
  if (isNaN(port)) {
    return val;
  }
  if (port >= 0) {
    return port; 
  }
  return false;
}

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }
  const bind = typeof server.port === 'string' ? 'Pipe ' + server.port : 'Port ' + server.port;
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

function onListening() {
  const addr = server.address();
  const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

// Cluster logic
if (cluster.isMaster && HOST !== 'heroku') {
  console.log(`Master ${process.pid} is running`);
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    //spawn new worker
    cluster.fork();
  });
} else if (cluster.isMaster && HOST === 'heroku') {
  for (let i = 0; i < WORKERS; i++) {
    cluster.fork();
  }
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
  });
} else {
  console.log(`Worker ${process.pid} started`);
  startServer();
}

if (config.LISTENER) {
  const scriptCount = config.LISTENER_COUNT * 1 || 10;
  for (let i = 0; i < scriptCount; i++) {
    queueWorker();
  }
}
